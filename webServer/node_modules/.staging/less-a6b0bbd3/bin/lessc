#!/usr/bin/env node

var path = require('path'),
    fs = require('../lib/less-node/fs'),
    os = require('os'),
    utils = require('../lib/less/utils'),
    Constants = require('../lib/less/constants'),
    errno,
    mkdirp;

try {
    errno = require('errno');
} catch (err) {
    errno = null;
}

var less = require('../lib/less-node'),
    pluginManager = new less.PluginManager(less),
    fileManager = new less.FileManager(),
    plugins = [],
    queuePlugins = [],
    args = process.argv.slice(1),
    silent = false,
    verbose = false,
    options = less.options;

options.plugins = plugins;
options.reUsePluginManager = true;

var sourceMapOptions = {};
var continueProcessing = true;

// Calling process.exit does not flush stdout always. Instead of exiting the process, we set the process' exitCode,
// close all handles and wait for the event loop to exit the process.
// @see https://github.com/nodejs/node/issues/6409
// Unfortunately, node 0.10.x does not support setting process.exitCode, so we need to call reallyExit() explicitly.
// @see https://nodejs.org/api/process.html#process_process_exitcode
// Additionally we also need to make sure that uncaughtExceptions are never swallowed.
// @see https://github.com/less/less.js/issues/2881
// This code can safely be removed if node 0.10.x is not supported anymore.
process.on('exit', function() { process.reallyExit(process.exitCode); });
process.on('uncaughtException', function(err) {
    console.error(err);
    process.exitCode = 1;
});
// This code will still be required because otherwise rejected promises would not be reported to the user
process.on('unhandledRejection', function(err) {
    console.error(err);
    process.exitCode = 1;
});

var checkArgFunc = function(arg, option) {
    if (!option) {
        console.error(arg + ' option requires a parameter');
        continueProcessing = false;
        process.exitCode = 1;
        return false;
    }
    return true;
};

var checkBooleanArg = function(arg) {
    var onOff = /^((on|t|true|y|yes)|(off|f|false|n|no))$/i.exec(arg);
    if (!onOff) {
        console.error(' unable to parse ' + arg + ' as a boolean. use one of on/t/true/y/yes/off/f/false/n/no');
        continueProcessing = false;
        process.exitCode = 1;
        return false;
    }
    return Boolean(onOff[2]);
};

var parseVariableOption = function(option, variables) {
    var parts = option.split('=', 2);
    variables[parts[0]] = parts[1];
};

var sourceMapFileInline = false;

function printUsage() {
    less.lesscHelper.printUsage();
    pluginManager.Loader.printUsage(plugins);
    continueProcessing = false;
}
function render() {

    if (!continueProcessing) {
        return;
    }

    var input = args[1];
    if (input && input != '-') {
        input = path.resolve(process.cwd(), input);
    }
    var output = args[2];
    var outputbase = args[2];
    if (output) {
        output = path.resolve(process.cwd(), output);
    }

    if (options.sourceMap) {

        sourceMapOptions.sourceMapInputFilename = input;
        if (!sourceMapOptions.sourceMapFullFilename) {
            